<?xml version="1.0" encoding="iso-8859-2"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 strict//EN" "http://www.w3.org/TR/xhtml11/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
  <title>C/C  : Optymalizacja w C/C   (by Gynvael Coldwind, 2007-05-08) @ wyklady.net  </title>
  <style type="text/css">
    @charset "iso-8859-2";
    *{
	vertical-align: top;
	font-family: Arial;
	font-size: 12px;
	color: #000;
	background-color: #FFF;
	margin: 0;
    }
    table {
	border-collapse: collapse;
    }
    td {
	vertical-align: top;
	padding: 3px 5px;
    }
    .time{
	white-space: nowrap;
	color: gray;
	background-color: #F7F7F7;
    }
    .sender{
	background-color: #F7F7F7;
	text-align: right;
	white-space: nowrap;
	color: #000099;
    }
    .msg-sender{
    }
    .self{
	background-color: #F7F7F7;
	text-align: right;
	white-space: nowrap;
	color: #900;
    }
    .msg-self {
	font-weight: bolder;
    }
    div.highlight {
	display: table-cell;
    }
    a {
	color: #900;
    }
    a:hover { 
	color: #808080;
	text-decoration: none;
    }
    .code{
	font-weight: bolder;
	color: #00b;
	font-family: monospace;
    }
    div.con{
	margin-top: -5px;
	margin-bottom: -5px;
	width: 500px;
	font-weight: bolder;
	background-color: #d0d0d0;
	padding: 5px;
	font-family: monospace;
    }
	span.bold{
	font-weight: bold;
	}
</style>
</head><body xml:lang="pl">
<table><tbody><tr><td class="time"></td><td class="sender"></td><td class="msg-sender">Temat wykladu:</td></tr><tr><td class="time"></td><td class="sender"></td><td class="msg-sender">C/C  : Optymalizacja w C/C   (by <span class="bold">Gynvael Coldwind</span>, 2007-05-08) @ <a href="http://web.archive.org/web/20080628085836/http://wyklady.net/">wyklady.net</a></td></tr><tr><td class="time"></td><td class="sender"></td><td class="msg-sender">Komentarze: <a href="http://web.archive.org/web/20080628085836/http://forum.wyklady.net/index.php?topic=107">http://forum.wyklady.net/index.php?topic=107</a></td></tr><tr><td class="time">18:04</td><td class="sender">Gynvael</td><td class="msg-sender">Witam wszystkich na moim pierwszym wykladzie w nowym sezonie ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Wyklad bedzie dotyczyc zagadnien optymalizacji (glownie pod katem szybkosci dzialania) oprogramowania pisanego w C/C++</td></tr><tr><td class="time">18:06</td><td class="sender">Gynvael</td><td class="msg-sender">Jeszcze 3 slowa o mnie, tak w ramach przedstawienia sie... jestem Gynvael Coldwind, pracuje jako reverse engineer i programista w hiszpanskiej firmie zajmujacej sie bezpieczenstwem klientow roznych bankow ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Obecnie skonczylem studia na politechnice wroclawskiej (informatyka) i czekam na obrone pracy inzynierskiej ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok tyle ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">teraz kwestia organizacyjna...</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pytania na privie, co ciekawsze bede tu przeklejac i odpowiadac</td></tr><tr><td class="time">18:07</td><td class="sender">Gynvael</td><td class="msg-sender">na reszte postaram sie odpowiedziec na privie ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Zaczne od definicji, co to jest optymalizacja... nie bede oryginalny i posluze sie wiki</td></tr><tr><td class="time">18:08</td><td class="sender">Gynvael</td><td class="msg-sender">Optymalizacja to metoda wyznaczania najlepszego rozwišzania (poszukiwanie ekstremum funkcji) z punktu widzenia okreslonego kryterium (wskaznik) jakosci (np. kosztu, drogi, wydajnosci).</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">(będzie głównie o optymalce pod wzgledem predkosci)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">w stosunku do oprogramowania mowimy tak na prawde o trzech wariantach optymalizacji:</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><img src="opt1.png" /></td></tr><tr><td class="time">18:09</td><td class="sender">Gynvael</td><td class="msg-sender">- optymalizacja pod wzgledem predkosci dzialania, czyli stanowczo najpopularniejsza ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- optymalizacja pod wzgledem zuzycia pamieci, tzn tak zeby oprogramowanie zuzywalo jej jak najmniej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- oraz optymalizacja pod wzgledem wielkosci kodu (i/lub danych)</td></tr><tr><td class="time">18:10</td><td class="sender">Gynvael</td><td class="msg-sender">Trojkat na powyzszym obrazku nalezy interpretowac w nastepujacy sposob:</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Czym bardziej zblizamy sie do ktoregos z rogow trojkata, tym bardziej oddalamy sie od reszty</td></tr><tr><td class="time">18:11</td><td class="sender">Gynvael</td><td class="msg-sender">Przykladowo, jesli chcemy uzyskac duza predkosc dzialania, to prawdopodobnie bedziemy musieli naduzyc kodu (patrz loop unrolling o ktorym bedzie troszke pozniej), lub np pamieci (patrz lookup tables o ktorych tez bedzie pozniej)</td></tr><tr><td class="time">18:12</td><td class="sender">Gynvael</td><td class="msg-sender">Idac w druga strone, jesli chcemy miec maly kod wynikowy, to prawdopodobnie bedziemy musieli skorzystac np. z kompresji, a dekompresja szybka nigdy nie byla, po za tym zuzywa troche pamieci</td></tr><tr><td class="time">18:13</td><td class="sender">Gynvael</td><td class="msg-sender">Teraz takie odpowiedz na takie male pytanie.. po co w zasadzie optymalizowac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Po co optymalizowac wielkosc kodu ?</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Albo inaczej, kiedy warto/trzeba ?</td></tr><tr><td class="time">18:14</td><td class="sender">Afro_PL</td><td class="msg-sender">kiedy kod jest zbyt duzy i wydluza czas pracy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- jesli piszemy pod bardzo specyficzna platforme na ktorej jest bardzo malo miejsca na kod</td></tr><tr><td class="time"></td><td class="sender">MeMeK</td><td class="msg-sender">dawno sie zaczelo?</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">np chcemy napisac nowy BIOS z super mega ficzerami na stary komp ktory ma kostki po 4kb... auc</td></tr><tr><td class="time">18:15</td><td class="sender">Gynvael</td><td class="msg-sender">MeMeK 10 minut temu</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">albo piszemy shellcode do wysploitowania jakiegos progsa a bufor (z roznych przyczyn) ma dokladnie 256 bajtow...</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- for fun...</td></tr><tr><td class="time">18:16</td><td class="sender">Gynvael</td><td class="msg-sender">przykladem for fun moze byc demoscena na ktorej bardzo popularne sa produkcje typu intro4k czy intro64k</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">warto rzucic okiem np na <a href="http://web.archive.org/web/20080628085836/http://awards.scene.org/">http://awards.scene.org/</a></td></tr><tr><td class="time">18:17</td><td class="sender">Gynvael</td><td class="msg-sender">innym przykladem moze byc gra .kkrieger, zajmujaca ponizej 100kb, a grafika doroownujaca takim produkcja jak Unreal czy nawet Unreal 2</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.theprodukkt.com/">http://www.theprodukkt.com/</a></td></tr><tr><td class="time">18:18</td><td class="sender">Gynvael</td><td class="msg-sender">po za tym czasem na ircu zbierze sie grupa ludzi i mysli jak cos napisac tak zeby dostac jak najmniejsza ilosc kodu wynikowego</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">przykladowo w przeciagu ostatniego roku bralem udzial w dwoch takich konstruktywnych -zabawach- ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pierwsza polegala na napisaniu procedury zmiany wartosci (int) na string'a zapisanego w HEX'a</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">czyli np 123 na 7B</td></tr><tr><td class="time">18:19</td><td class="sender">Gynvael</td><td class="msg-sender">z tego co pamietam to udalo nam sie zejsc ponizej 20 bajtow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ostatnio za sprawa fr3m3na tworzylismy kompilatory jezyka Brainfuck, tak zeby byly jak najmniejsze</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">adam_i uzyskal wynik 126 bajtow</td></tr><tr><td class="time">18:20</td><td class="sender">Gynvael</td><td class="msg-sender">ok dalej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Po co optymalizowac pod wzgledem wielkosci uzywanej pamieci</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- pamiec nawet teraz jest ograniczona... caszem piszemy jakies wieeelkie obliczenia ktore najchetniej by zjadly 20gb ramu.. jako ze nie kazdy tyle ma, to trzeba optymalizowac</td></tr><tr><td class="time">18:21</td><td class="sender">Gynvael</td><td class="msg-sender">- na niektorych systemach wbudowanych (embedded) pamieci nie ma za duzo, przykladem moga byc na przyklad komoorki ktore dopiero ostatnio maja wiecej niz 1mb pamieci</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">skala optymalizacji tutaj jest tak na prawde rozna</td></tr><tr><td class="time">18:22</td><td class="sender">Gynvael</td><td class="msg-sender">mozemy czasem walczyc o 1gb</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a innym razem o 5 bajtow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">A po co optymalizowac jesli chodzi o szybkosc ?</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to chyba kazdy wie ;&gt; jednak lepiej miec 100 fps w Quake 3 niz 15 ;&gt;</td></tr><tr><td class="time">18:23</td><td class="sender">Gynvael</td><td class="msg-sender">niektorzy nieslusznie uwazaja ze skoro mamy super sprzety to nie trzeba optymalizowac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">nie jest to do konca prawda ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">sprzet jest szybki, ale jeszcze nie na tyle by mozna kompletnie zaniedbac optymalizacje</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">przykladem moze byc raytracing i rendering np w takim 3D Max</td></tr><tr><td class="time">18:24</td><td class="sender">Gynvael</td><td class="msg-sender">szybszy sprzet co najwyzej liniowo poprawi czas renderowania</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">zamiast 1h bedziemy czekac 30 minut</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ale jesli ktos z programistow wpadnie na jakis pomysl co mozna dobrze zoptymalizowac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to to 1h moze zejsc i do 2 minut</td></tr><tr><td class="time">18:25</td><td class="sender">Gynvael</td><td class="msg-sender">Teraz takie dwie wazne rzeczy jesli chodzi o optymalizacje</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">najpierw cytat (by Donald Knuth): &quot;przedwczesna optymalizacja jest zrodlem wszelkiego zla&quot;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">chodzi glownie o to ze optymalizacja na pewno nie poprawia czytelnosci kodu, ani dla nas, ani dla kompilatora</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">(mowie o tej recznej)</td></tr><tr><td class="time">18:26</td><td class="sender">Gynvael</td><td class="msg-sender">ciekawostka od darkjames'a</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">&lt;darkjames&gt; <a href="http://web.archive.org/web/20080628085836/http://www.catb.org/~esr/writings/taoup/html/ch12s01.html">http://www.catb.org/~esr/writings/taoup/html/ch12s01.html</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">&lt;darkjames&gt; [113] The eighteen-month doubling time usually quoted for Moore's Law implies that you can collect a 26% performance gain just by buying new hardware in six months.</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ona dotyczy w sumie drugiej rzeczy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mianowicie czasem po prostu nie warto optymalizowac</td></tr><tr><td class="time">18:27</td><td class="sender">Gynvael</td><td class="msg-sender">jesli koszt wynajecia programisty ktory przeprowadzi optymalizacje jest wiekszy niz spodziewany zysk</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to po prostu nie warto tego robic</td></tr><tr><td class="time">18:28</td><td class="sender">Gynvael</td><td class="msg-sender">Co do samej optymalizacji</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to optymalizowac mozemy na roznych poziomach</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">na samej gorze jest optymalizacja ktora wykonujemy juz na poziomie projektowania oprogramowania</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">w momencie kiedy decydujemy np ze uzyjemy C++ bo jest szybszy niz Java</td></tr><tr><td class="time">18:29</td><td class="sender">Gynvael</td><td class="msg-sender">czy Java bo ma mniejsze binarki niz VB</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">niz JPG bo zajmuje mniej miejsca niz BMP</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pozniej, w momencie planowania implementacji</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">(lub pozniej w ramach procesu optymalizacji)</td></tr><tr><td class="time">18:30</td><td class="sender">Gynvael</td><td class="msg-sender">przychodzi moment wyboru algorytmu</td></tr><tr><td class="time">18:31</td><td class="sender">Gynvael</td><td class="msg-sender">musimy byc swiadomi w tym momencie tego ze np sortowanie babelkowe sie pisze szybko milo i przyjemnie</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ale jest duzo wolniejsze niz np quick sort</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">musimy byc rowniez swiadomi ze radix sort moze byc szybszy niz quick sort ;&gt;</td></tr><tr><td class="time">18:32</td><td class="sender">Gynvael</td><td class="msg-sender">na koncu mamy optymalizacje na poziomie implementacji</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a w zasadzie dwa rodzaje</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pierwszy polega na stosowaniu znanych sztuczek dzialajacych w danym jezyku (language-specific)</td></tr><tr><td class="time">18:33</td><td class="sender">-!-</td><td class="msg-sender">Netsplit krakow.ircnet.pl &lt;-&gt; katowice.ircnet.pl quits: _m, d0b0c0p, Requel</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a drugi na zblizenie sie do platformy na ktora piszemy, wykorzystanie jej mozliwosci poprzez sformuowanie kodu w najbardziej optymalny dla niej sposob (np wykorzystanie pipeliningu, SSE)</td></tr><tr><td class="time">18:34</td><td class="sender">Gynvael</td><td class="msg-sender">musimy jednak pamietac ze zbytnie zblizenie sie do platformy bardzo utrudnia przenoszenie programow pozniej</td></tr><tr><td class="time">18:36</td><td class="sender">Gynvael</td><td class="msg-sender">SSE &lt;=- chodzilo mi o Streaming SIMD Extension, czyli rozszerzenie procesora wspomagajace powtarzajace sie operacje na duzych partiach danych (technicznie wyglada to tak ze naraz sie robi np dodawania na 4rech floatach zamiast na jednym)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">SSE, MMX, etc to temat na oddzielnny wyklad wiec sie zaglebial nie bede</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok koniec teorii ;&gt;</td></tr><tr><td class="time">18:37</td><td class="sender">Gynvael</td><td class="msg-sender">Reszta wykladu bedzie poswiecona optymalizowaniu pod wzgledem szybkosci dzialania</td></tr><tr><td class="time"></td><td class="sender">-!-</td><td class="msg-sender">Netsplit torun.ircnet.pl &lt;-&gt; katowice.ircnet.pl quits: _m, d0b0c0p, Requel</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Wiec tak, po pierwsze istnieja programy ulatwiajace lokalizowanie miejsc ktore trzeba zoptymalizowac</td></tr><tr><td class="time">18:38</td><td class="sender">Gynvael</td><td class="msg-sender">Sa to tzw profilery... do pakietu gcc jest dostepny profiler gprof</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">po za tym Intel wydal swoj VTune (niestety platny, ale mozna eval. version sciagnac)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">dodatkowo pod *nixy zostal stworzony profiler Valgrind</td></tr><tr><td class="time">18:39</td><td class="sender">Gynvael</td><td class="msg-sender">taki profiler zazwyczaj umie wskazac ktora funkcja jest najwiecej razy wywolywana, ktora na najdluzszy okres czasu &quot;zjada&quot; procesor etc</td></tr><tr><td class="time">18:40</td><td class="sender">Gynvael</td><td class="msg-sender">oprocz profilerow warto miec swoje jakies procedurki ktore mierza czas / ilosc cykli procesora</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">na potrzeby tego wykladu bede stosowal <a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/rtdsc.c">http://vexillium.org/~gynvael/opt/rtdsc.c</a> oraz <a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/speed.h">http://vexillium.org/~gynvael/opt/speed.h</a></td></tr><tr><td class="time">18:41</td><td class="sender">Gynvael</td><td class="msg-sender">rtdsc.c zawiera wrapper na polecenie RTDSC ktora zwraca ilosc wykonanych do tej pory cykli procesora</td></tr><tr><td class="time">18:42</td><td class="sender">Gynvael</td><td class="msg-sender">speed.h zawiera funkcje tcount()... w momencie drugiego wywolania funkcji na STDERR pojawia sie informacje ile czasu minelo od poprzedniego wywolania tcount()</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">rtdsc() bede uzywal do obliczenia roznicy przed i po rozpoczeciu kodu</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">obie te metody NIE SA obiektywne, a tym bardziej precyzyjne</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">natomiast wystarczaja zeby odpowiedziec na pytanie &quot;czy kod dziala szybciej&quot;</td></tr><tr><td class="time">18:44</td><td class="sender">Gynvael</td><td class="msg-sender">bart^xt zauwazyl ze rtdsc moze klamac na wieloprocesorowych stacjach</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">;&gt;</td></tr><tr><td class="time">18:45</td><td class="sender">Gynvael</td><td class="msg-sender">niemniej jednak na kompie na ktorym teraz -siedze- mam jeden core, wiec wyniki ktore bede podawac beda wmiare ok ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">rtdsc ofc jest platform-specyfic... tzn x86</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">dobra</td></tr><tr><td class="time">18:46</td><td class="sender">Gynvael</td><td class="msg-sender">a teraz bedzie krotka lista wmiare standardowych trikow na zoptymalizowanie kodu, wraz z przykladami i pomiarami</td></tr><tr><td class="time">18:47</td><td class="sender">Gynvael</td><td class="msg-sender">1. Lookup table</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts4.c">http://vexillium.org/~gynvael/opt/opts4.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">sytuacja wyglada tak</td></tr><tr><td class="time">18:48</td><td class="sender">Gynvael</td><td class="msg-sender">mamy jakies 'j' ktore jest zmienne i przyjmuje wartosci od 0 do 25</td></tr><tr><td class="time">18:49</td><td class="sender">Gynvael</td><td class="msg-sender">w zaleznosci od tego co przyjmie 'j', do zmiennej 'g' dodajemy jakas wartosc</td></tr><tr><td class="time">18:50</td><td class="sender">Gynvael</td><td class="msg-sender">musimy sprawdzic co 'j' przyjelo i odpowiednio zareagowac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">w kodzie jest switch/case</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">kod jest wykonywany 100mln razy, tak zeby bylo co mierzyc</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001578 TIME: 1.57800 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 2360008915</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">u mnie kod wykonuje sie 'tyle'</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pytanie brzmi 'jak mozna to zoptymalizowac'</td></tr><tr><td class="time">18:51</td><td class="sender">Gynvael</td><td class="msg-sender">niektorzy ucza zeby zamiast 'switch/case' dac else/if, ale to jest zly pomysl;&gt; o tym za chwile</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mozna jednak stworzyc tablice z wartosciami</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i zrobic tablica[j % 26]</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a dokladniej g += tablica[j % 26];</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">zaoszczedzi to paru porownan i paru skokow</td></tr><tr><td class="time">18:52</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts5.c">http://vexillium.org/~gynvael/opt/opts5.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">tak wyglada zoptymalizowany kod</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001468 TIME: 1.46800 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 2191607761</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i faktycznie wykonuje sie odrobine szybciej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">powstaja dwa pytania</td></tr><tr><td class="time">18:53</td><td class="sender">Gynvael</td><td class="msg-sender">1) czemu tylko tyle</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">2) czemu nie if/else</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">1) &lt;=- nowoczesne kompilatory w przypadku switch i wartosci kolejnych tworza tak zwane jump tables, czyli tablice z pointerami adresow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i w domysle wykonywane jest goto adres_skoku[j % 16]</td></tr><tr><td class="time">18:54</td><td class="sender">Gynvael</td><td class="msg-sender">a to jest po prostu szybkie, jako ze jedyne porownanie jakie kompilator tam wrzuci to czy j nie jest czasem mniejszy od 0 lub wiekszy od 26</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">% 26 tam</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">* 25</td></tr><tr><td class="time">18:55</td><td class="sender">Gynvael</td><td class="msg-sender">2) a zapiszmy to za pomoca if/else i zobaczmy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts6.c">http://vexillium.org/~gynvael/opt/opts6.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000003953 TIME: 3.95300 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1621625649</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">auc, ponad 2 razy gorzej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">kompilator domyslnie przerobi to na serie sprawdzen i skokow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a to szybkie nie jest</td></tr><tr><td class="time">18:56</td><td class="sender">Gynvael</td><td class="msg-sender">czasem jednak trafimy na kompilator ktory jest przyglupawy i nie umie w przypadku switcha zrobic jump table</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy mozemy sprobowac zrobic if/elseif, ale w sposob przypominajacy drzewo</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">na poczatek, podzielmy te wszystkie ify na czesc mniejsza od 13 i reszte</td></tr><tr><td class="time">18:57</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts7.c">http://vexillium.org/~gynvael/opt/opts7.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000003187 TIME: 3.18700 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 495542677</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">jak widac jest lepiej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">idzmy o krok dalej i zromy kolejne podzialy</td></tr><tr><td class="time">18:58</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts8.c">http://vexillium.org/~gynvael/opt/opts8.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">jak widac teraz dodatkowo dzielone jest na galaz mniejsza od 6 i reszte</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">oraz mniejsza od 19 i reszte</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">podzial na &lt;13 nadal zostal</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000002765 TIME: 2.76500 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 4130054772</td></tr><tr><td class="time">18:59</td><td class="sender">Gynvael</td><td class="msg-sender">2.765sec jest lepsze niz 3.953</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mozna isc z tym podzialem dalej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ale niestety nie zblizymy sie ani do switch/case opartego na jump table</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ani do lookup table</td></tr><tr><td class="time">19:00</td><td class="sender">Gynvael</td><td class="msg-sender">niemniej jednak warto o tym pamietac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok dalej ;&gt;</td></tr><tr><td class="time">19:01</td><td class="sender">Gynvael</td><td class="msg-sender">3. (2 byla optymalizacja ifow) &quot;aliasy&quot; na parametry przekazywane pointerem</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts9.c">http://vexillium.org/~gynvael/opt/opts9.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mamy taka sytuacje</td></tr><tr><td class="time">19:02</td><td class="sender">Gynvael</td><td class="msg-sender">mamy funkcje func() ktora dostaje inta, przekazywanego pointerem</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">nastepnie 100mln razy przekazyje tego wartosc wskazywana przez ten pointer do funkcji dodaj</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000937 TIME: 0.93700 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1420670838</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">problemem tutaj tak na prawde jest to ze &quot;*sth&quot; wykonuje sie 100mln razy</td></tr><tr><td class="time">19:03</td><td class="sender">Gynvael</td><td class="msg-sender">czyli 100mln razy procesor musi sprawdzic jaka wartosc ma pointer sth (tj odczytac ja z pamieci) a nastepnie odczytac z pamieci inta wskazyywanego przez sth</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">rozwiazaniem problemu jest stworzenie zmiennej lokalnej ktora raz na poczatku funkcji dostanie wartosc *sth</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a potem bedziemy uzywac tejze zmiennej zamiast *sth</td></tr><tr><td class="time">19:04</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts10.c">http://vexillium.org/~gynvael/opt/opts10.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000875 TIME: 0.87500 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1317263034</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">0.06 sec szybciej, nieduzo, ale zawsze cos</td></tr><tr><td class="time">19:05</td><td class="sender">Gynvael</td><td class="msg-sender">nalepszy pameitac ze czasami liczymy czas obliczeniowy w godzinach, i to by moglo byc np 87 zamiast 93 godzin ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">6 godzin juz robi roznice ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">4. Natywne slowo maszyny</td></tr><tr><td class="time">19:06</td><td class="sender">Gynvael</td><td class="msg-sender">jakos tak sie przyjelo ze WORD to 16 bitow, ale jest to w sumie niezgodne z prawda</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">WORD jest typem natywnym dla danej platformy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pod dosem bylo to 16 bitow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">pod winda slowo ma juz 32 lub nawet 64 bity</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">operujac na natywnej wielkosci zmiennej (czyli na natywnym WORD) program dziala szybciej niz na wielkosciach mniejszych</td></tr><tr><td class="time">19:08</td><td class="sender">Gynvael</td><td class="msg-sender">wezmy za przyklad jakas petle i wrzucmy w nia troche obliczen arytmetycznych</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">siedze na maszynie 32 bitowej wiec jako odnosnik uzyje int'a</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts12.c">http://vexillium.org/~gynvael/opt/opts12.c</a></td></tr><tr><td class="time">19:09</td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000002797 TIME: 2.79700 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 4188994405</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok, to teraz wrzuce zamiast int np short &quot;bo jest mniejszy wiec szybciej bedzie sie liczyc&quot; (wniosek nieprawdziwy, ale czesto wysnuwany)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts11.c">http://vexillium.org/~gynvael/opt/opts11.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000003171 TIME: 3.17100 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 461919159</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">huh, wolniej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">no to &quot;char&quot;</td></tr><tr><td class="time">19:10</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts13.c">http://vexillium.org/~gynvael/opt/opts13.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000003109 TIME: 3.10900 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 361602909</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">szybciej, ale nadal wolno...</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wniosek: int jest na prawde natywny dla maszyny, wiec jest szybszy</td></tr><tr><td class="time">19:11</td><td class="sender">Gynvael</td><td class="msg-sender">DeeTahPanLtah: Bita ? ;&gt; nieee my nie bedziemy Bili intow zeby je przyspieszyc ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok dalej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">5. ALU &gt; FPU</td></tr><tr><td class="time">19:12</td><td class="sender">Gynvael</td><td class="msg-sender">ALU, czyli jednostka arytmetyczna od operacji na liczbach naturalnych/calkowitych jest szybszy niz FPU (czyli jednotska od floatow i double)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">test ?</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">zmienmy w powyzszych przykladach int na float</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts14.c">http://vexillium.org/~gynvael/opt/opts14.c</a></td></tr><tr><td class="time">19:13</td><td class="sender">Gynvael</td><td class="msg-sender">chcecie to odpalcie ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">przed wykladem i sie 92 sekundy to wykonywalo</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">hehe</td></tr><tr><td class="time">19:14</td><td class="sender">Gynvael</td><td class="msg-sender">jesli chodzi o precyzje obliczen</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to float jest oczywiscie szybszy niz double</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a double niz long double</td></tr><tr><td class="time">19:15</td><td class="sender">Gynvael</td><td class="msg-sender">Zdecydowanie najgorsza sytuacja jest gdy nie ma normalnego koprocesora FPU, i wszystkie floatingi sa emulowane</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy mozemy zapomniec wogoole o uzywaniu floatow</td></tr><tr><td class="time">19:16</td><td class="sender">Gynvael</td><td class="msg-sender">zreszta, jesli mamy mozliwosc i nie potrzebujemy mega precyzji, to mozna sie przerzucic z floatow na inty</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i powiedzmy dedykowac jeden bajt dla &quot;liczby po przecinku&quot;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a pozostale 3 na czesc &quot;przed przecinkiem&quot; ;&gt;</td></tr><tr><td class="time">19:17</td><td class="sender">Gynvael</td><td class="msg-sender">6. Loop jamming</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">loop jamming to po prostu laczenie petli</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts15.c">http://vexillium.org/~gynvael/opt/opts15.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000984 TIME: 0.98400 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1466389555</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">polaczenie petli w jedna</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">daje lepszy rezultat</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts16.c">http://vexillium.org/~gynvael/opt/opts16.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000562 TIME: 0.56200 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 823512458</td></tr><tr><td class="time">19:18</td><td class="sender">Gynvael</td><td class="msg-sender">jest to w sumie logiczne i oczywiste</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">natomiast jest przypadek</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">kiedy dwie petle sa jednak szybsze niz jedna</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mianowiscie jesli kodu w petli jest duuuzo</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy rozbicie na dwie petle moze dac lepszy efekt (ma to zwiazek z cachowaniem procka etc)</td></tr><tr><td class="time">19:19</td><td class="sender">Gynvael</td><td class="msg-sender">7. Loop unroling</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to w sumie jest najstarsza technika pod sloncem ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts1.c">http://vexillium.org/~gynvael/opt/opts1.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mamy sobie duza tablie (20mln intow)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i chcemy ja zsumowac</td></tr><tr><td class="time">19:20</td><td class="sender">Gynvael</td><td class="msg-sender">najprostsze rozwiazanie to dodanie kazdego elementu w petli, jeden po drugim</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000203 TIME: 0.20300 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 307088127</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">loop unrolling polega na &quot;rozwinieciu&quot; petli w ten sposob zeby zamiast jednego dodawania w ciele byly np 4, i zeby zamiast i++ bylo i+=4</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts2.c">http://vexillium.org/~gynvael/opt/opts2.c</a></td></tr><tr><td class="time">19:21</td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000171 TIME: 0.17100 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 255730705</td></tr><tr><td class="time">19:22</td><td class="sender">Gynvael</td><td class="msg-sender">dlaczego tak jest ? zamiast 4rech i++ mamy jedno i+=4, i zamiast 4rech i &lt; WIELKSOC mamy jedno</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">8. Pipelining</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to jest juz typowe platform-spec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mianowicie CPU ktore wiekszosc z nas ma w swoich kompach moze wykonac kilka operacji naraz</td></tr><tr><td class="time">19:23</td><td class="sender">Gynvael</td><td class="msg-sender">pod warunkiem ze te operacje nie wymagaja nawzajem swoich wartosci</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts3.c">http://vexillium.org/~gynvael/opt/opts3.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wezmy pod uwage taki kod</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">petla nadal rozwinieta</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ale sumujemy do 4rech roznych zmeinnych</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a na koncu po petli je dodajemy do siebie</td></tr><tr><td class="time">19:24</td><td class="sender">Gynvael</td><td class="msg-sender">dzieki temu sa to 4ry oddzielne operacje</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ktore moga byc wykonane jednoczesnie</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000156 TIME: 0.15600 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 214483353</td></tr><tr><td class="time">19:25</td><td class="sender">Gynvael</td><td class="msg-sender">9. Pointery</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">&lt;reqamst&gt; dlaczego cpu automatycznie opts2 nie zrobi takiego triku w opts3?</td></tr><tr><td class="time">19:26</td><td class="sender">Gynvael</td><td class="msg-sender">poniewaz w opts2 mamy 4ry razy uzyte sum +=.. wiec druga linia z sum += wymaga wyniku z pierwszej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">w przypadku opts3 sum2 nie wymaga wyniku sum1</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wiec nie musi na niego 'czekac'</td></tr><tr><td class="time">19:27</td><td class="sender">Gynvael</td><td class="msg-sender">ok</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">dalej</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to w sumie blad robiony przez poczatkujacych</td></tr><tr><td class="time">19:28</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts17.c">http://vexillium.org/~gynvael/opt/opts17.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mamy funkcje</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ktora potrzebuje pointer</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">*ktora potrzebuje strukture</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">blad polega na tym ze przekazujemy strukture cala</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i jest ona caaala kopiowana</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mimo iz nie korzystamy z niej calej</td></tr><tr><td class="time">19:29</td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001375 TIME: 1.37500 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 2070562285</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">gdybysmy skorzystali z pointera do przekazania structa</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts18.c">http://vexillium.org/~gynvael/opt/opts18.c</a></td></tr><tr><td class="time">19:30</td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000985 TIME: 0.98500 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1487939201</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">rezultat byl by lepszy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wracajac do loop unrolling</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">&lt;mik01aj&gt; mam pytanko... czy to, ze rozwinelismy dokladnie 4 cykle petli ma znaczenie? czy dla 5 wynik bylby podobny?</td></tr><tr><td class="time">19:31</td><td class="sender">Gynvael</td><td class="msg-sender">to kwestia poeksperymentowania</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">slyszalem rozne wersje, niektorzy polecali zeby do 4rech rozwijac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">inni do 8</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">warto sie tym pobawic i samemu okreslic ;&gt;</td></tr><tr><td class="time">19:32</td><td class="sender">Gynvael</td><td class="msg-sender">10. Prekalkulacja wynikow / cache'owanie wynikow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">co do cacheowania wynikow, @ przykald z sumowaniem (Ten w loop unroll uzyty)</td></tr><tr><td class="time">19:33</td><td class="sender">Gynvael</td><td class="msg-sender">zalozmy ze takie sumowanie bylo by robione bardzo czesto</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy warto by zrobic to tylko raz, a potem pamietac wynik</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">i w miare zmian, aktualizowac ta sume</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy nie trzeba by jej znowu przeliczac</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">a co do reszty</td></tr><tr><td class="time">19:34</td><td class="sender">Gynvael</td><td class="msg-sender">wezmy jakas wolna operacja matematyczna...</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">hmm</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">hmm</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">sinus ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">sinus, realizowany przez instrukcje FPU FSIN jest wolny</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts19.c">http://vexillium.org/~gynvael/opt/opts19.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">zalozmy ze musimy duuuzo razy jakas wartosc sinusa policzyc</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001796 TIME: 1.79600 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 2679071545</td></tr><tr><td class="time">19:35</td><td class="sender">Gynvael</td><td class="msg-sender">zalozmy rowniez ze nie potrzebujemy wszystkich mozliwych katow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">sin(0.00), sin(0.01), sin(0.02) etc co 0.01 nam wystarczy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">mozna stworzyc tablice z wartosciami sin dla wszystkich tych wartosci</td></tr><tr><td class="time">19:36</td><td class="sender">Gynvael</td><td class="msg-sender">taka gdzie beda zapisane juz wczesniej wyliczone wyniki</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">tablica nie bedzie bardzo duza</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts20.c">http://vexillium.org/~gynvael/opt/opts20.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">wtedy zamiast f = sin(kat) bedziemy robic</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">f = sintab[314]; //sinf(3.14f);</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">czyli f = sintab[(int)(kat * 100)];</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000000093 TIME: 0.09300 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 139743015</td></tr><tr><td class="time">19:37</td><td class="sender">Gynvael</td><td class="msg-sender">1.796 vs 0.093</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">roznica niemala</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ta metoda jest czesto w grach wykorzystywana</td></tr><tr><td class="time">19:38</td><td class="sender">Gynvael</td><td class="msg-sender">hmm</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">czas sie powoli konczy</td></tr><tr><td class="time">19:39</td><td class="sender">Gynvael</td><td class="msg-sender">ale jeszcze o kilku metodach chcial bym powiedzeic</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">11. wielowymiarowe tablice</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">jesli chcemy policzyc sume z wielowymiarowej tablicy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">np</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">int dane[2000][1000];</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to NIE robimy tak:</td></tr><tr><td class="time">19:40</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts21.c">http://vexillium.org/~gynvael/opt/opts21.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000002750 TIME: 2.75000 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 4094346580</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">bledem tutaj jest iteracja po kolumnach zamiast po wierszach</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">baaardzo to psuje cache'owanie procesorowi</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">poprawna wersja, czyli najpierw wiersze</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">to</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts22.c">http://vexillium.org/~gynvael/opt/opts22.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001312 TIME: 1.31200 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1981093587</td></tr><tr><td class="time">19:41</td><td class="sender">Gynvael</td><td class="msg-sender">pewne zrodla twierdza ze dobrze jest aby wiersz mial dlugosc potegi 2jki, nawet jesli to bedzie sie wiazalo z nadmiarowoscia</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts23.c">http://vexillium.org/~gynvael/opt/opts23.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001312 TIME: 1.31200 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1959388872</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">w moim przypadku nie robi to jednak duzej roznicy</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">natomiast mozemy splaszczyc ta tablice</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">tak zeby zamiast [2000][1000] otrzymac [2000*1000]</td></tr><tr><td class="time">19:42</td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://vexillium.org/~gynvael/opt/opts24.c">http://vexillium.org/~gynvael/opt/opts24.c</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">TICKS: 000001171 TIME: 1.17100 sec</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">RDTSC DIFF: 1742240367</td></tr><tr><td class="time">19:44</td><td class="sender">Gynvael</td><td class="msg-sender">ok</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">jeszcze teraz kilka porad, juz bez przykladow</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- rekusja jest zla, nie uzywac, za duzo czasu sie traci na wywolanie funkcji</td></tr><tr><td class="time">19:45</td><td class="sender">Gynvael</td><td class="msg-sender">- jesli musimy czesto dzielic floata przez okreslona stala wartosc, lepiej wyliczyc wyrazenie 1.0f / wartosc wczesniej, i mnozyc przez nie</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- puts jest szybsze od printf, ale oczywiscie mniej elastyczne ;&gt;</td></tr><tr><td class="time">19:46</td><td class="sender">Gynvael</td><td class="msg-sender">- jesli mamy plik z danymi, pliki binarne wymagaja mniej przetwarzania niz pliki tekstowe</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- inline czasami nie dziala, #define zawsze</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- w niektorych systemach jest funkcja mallopt gdzie mozemy ustawic opcje MAXFAST, wtedy alokacja pamieci via malloc dziala szybko</td></tr><tr><td class="time">19:47</td><td class="sender">Gynvael</td><td class="msg-sender">ad rekursja .. tak chodzi o rekurncje ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- jesli mamy petla { funkcja() }, to warto to zmeinic na funkcja() { petla { } }</td></tr><tr><td class="time">19:48</td><td class="sender">Gynvael</td><td class="msg-sender">- cache w CPU jest podzielony na male bloczki... jesli trzymamy zmienne z ktorych czesto korzystamy &quot;blisko siebie&quot; w pameici, wtedy jest wieksza szansa ze CPU ma ten bloczek z obydwoma (wieksza liczba) tymi zmiennymi scachowany.. struct sie klania ;&gt;</td></tr><tr><td class="time">19:49</td><td class="sender">Gynvael</td><td class="msg-sender">- jesli mamy kilka warunkow w if... if(a &amp;&amp; b &amp;&amp; c).. to pierwszy powinien byc ten ktory NAJCZESCIEJ jest FALSZYWY, w przypadku if(a || b || c) pierwszy powinien byc ten ktory jest najczesciej PRAWDZIWY</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">(wtedy pozostale nie sa sprawdzane)</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">- jesli sie ma klika prockow / rdzeni, warto pomyslec o multi threadingu ;&gt;</td></tr><tr><td class="time">19:50</td><td class="sender">Gynvael</td><td class="msg-sender">- warto znac swoj kompilator, i jego opcje.. -O3... etc.. kompilator bardzo duzo rzeczy zoptymalizuje sam.. ale nie wszystko</td></tr><tr><td class="time">19:51</td><td class="sender">Gynvael</td><td class="msg-sender">- kompilator lepiej optymalizuje jeden duzy plik niz ten sam kod rozbity na kilka malych plikow (glownie o wielkosc kodu tu chodzi)... np w projekcie ReactOS przed kompilacja lacza wszystkie zrodla danego modulu w jeden</td></tr><tr><td class="time">19:52</td><td class="sender">Gynvael</td><td class="msg-sender">- optymalizacja na poziomie assemblera i tak zawsze bedzie lepsza, mimo iz kompilatory sa coraz lepsze... jesli chce sie cos zrobic dobrze, trzeba to zrobic samemu.. jesli duzo operujemy na grafice, warto zainteresowac sie SSE, SSE2, SSE3, SSSE3 czy SSE4 ktory ma wyjsc niedlugo, oraz MMX, i obydwoma 3DNow!</td></tr><tr><td class="time">19:53</td><td class="sender">Gynvael</td><td class="msg-sender">- rozgalezienia sa zle:</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">if(b &gt; 10) a += 5; else c +=2; jest WOLNIEJSZE niz a += 5; if(b &lt;= 10) { a -= 5; c += 2; }</td></tr><tr><td class="time">19:54</td><td class="sender">Gynvael</td><td class="msg-sender">- inicjalizacja wartosci (int a = 5) jest szybsza niz nadawanie wartosci (int a; a = 5;) (chociaz kompilator powinien o to dbac)</td></tr><tr><td class="time">19:55</td><td class="sender">Gynvael</td><td class="msg-sender">- kopiowanie kilku bajtow na raz (np poprzez cast tablicy char[] na int*) jest szybsze niz pojedynczych bajtow.. to samo jesli chodzi o porownywanie</td></tr><tr><td class="time">19:56</td><td class="sender">Gynvael</td><td class="msg-sender">- i inne ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">temat optymalizacji jest baardzo szeroki, polecam w sumie google jako dobry zbior porad.. ale nie wierzcie we wszystkie ;&gt; warto samemu sprawdzic</td></tr><tr><td class="time">19:57</td><td class="sender">Gynvael</td><td class="msg-sender">OK ;&gt; na koniec zrodla</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.abarnett.demon.co.uk/tutorial.html">http://www.abarnett.demon.co.uk/tutorial.html</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.tantalon.com/pete/cppopt/main.htm">http://www.tantalon.com/pete/cppopt/main.htm</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.prism.uvsq.fr/~cedb/local_copies/lee.html">http://www.prism.uvsq.fr/~cedb/local_copies/lee.html</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.eventhelix.com/RealtimeMantra/Basics/OptimizingCAndCPPCode.htm">http://www.eventhelix.com/RealtimeMantra/Basics/OptimizingCAndCPPCode.htm</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.rddvs.com/FasterC/">http://www.rddvs.com/FasterC/</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.azillionmonkeys.com/qed/optimize.html">http://www.azillionmonkeys.com/qed/optimize.html</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://www.codeproject.com/cpp/C">http://www.codeproject.com/cpp/C</a></td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">Nie ze wszystkim niestety zdazylem, moze bedzie druga czesc jesli wyrazicie taka potrzebe</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender"><a href="http://web.archive.org/web/20080628085836/http://forum.wyklady.net/index.php?topic=107.0">http://forum.wyklady.net/index.php?topic=107.0</a> &lt;=- tutaj mozna komentowac i oceniac wyklad</td></tr><tr><td class="time">19:58</td><td class="sender">Gynvael</td><td class="msg-sender">jesli ktos by chcial poprowadzic o czyms wyklad to msg defc0n ;&gt;</td></tr><tr><td class="time"></td><td class="sender">Gynvael</td><td class="msg-sender">ok tyle ;&gt; dziekuje za wspolnie spedzony czas i zapraszam na kolejne wyklady ;&gt;</td></tr></tbody></table></body></html>




<!--
-->
